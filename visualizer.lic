=begin
  This script will create a new window and load images built for the Visualizer script
  for different locations across Gemstone IV.

  Add to your autostart with the following command:

  ;autostart add visualizer

  or Global with

  ;autostart add --global visualizer

         author: Selfane
   contributors: Tysong
            art: Alosaka, Oro
        version: 0.10.0

  Changelog:
  0.10.0  - Complete refactor with namespace, YAML config, modern Ruby practices
  0.09.2  - Rubocop cleanup, File.join usage, failsafe upon no Visualizer folder created
  0.09.1  - Proper Art credit
  0.09    - Initial Script Upload
=end

require 'yaml'
require 'fileutils'
require 'digest'
require 'open-uri'
require 'net/http'
require 'uri'
require 'zlib'
require 'rubygems/package'
require 'openssl'
require 'time'

module Visualizer
  # GitHub repository configuration
  GITHUB_REPO = 'mrhoribu/visualizer'
  GITHUB_BRANCH = 'main'
  MANIFEST_URL = "https://raw.githubusercontent.com/#{GITHUB_REPO}/#{GITHUB_BRANCH}/manifest.yaml"
  # Validates file checksums against manifest
  class ChecksumValidator
    def self.calculate_checksum(file_path)
      return nil unless File.exist?(file_path)
      Digest::SHA256.file(file_path).hexdigest
    end

    def self.validate?(file_path, expected_checksum)
      return false if expected_checksum.nil?
      calculate_checksum(file_path) == expected_checksum
    end
  end

  # Manages asset downloads and updates from GitHub
  class AssetManager
    VISUALIZER_DIR = File.join(SCRIPT_DIR, 'Visualizer')
    MANIFEST_PATH = File.join(VISUALIZER_DIR, 'manifest.yaml')
    MANIFEST_CACHE_HOURS = 24

    attr_reader :manifest

    def initialize
      @manifest = {}
      @base_url = "https://raw.githubusercontent.com/#{GITHUB_REPO}/#{GITHUB_BRANCH}/images"
      ensure_directory_exists
    end

    def check_and_update_assets
      respond 'Checking for asset updates...'
      
      unless download_manifest
        respond 'Could not download manifest. Using local assets.'
        return load_local_manifest
      end

      # Check if this is a new installation (no images yet)
      current_image_count = Dir.glob(File.join(VISUALIZER_DIR, '*.png')).count
      if current_image_count == 0 && @manifest.size > 100
        respond "New installation detected. Downloading repository archive for faster initial setup..."
        return bulk_download_repository if attempt_bulk_download
      end

      missing_assets = find_missing_assets
      outdated_assets = find_outdated_assets

      if missing_assets.empty? && outdated_assets.empty?
        respond 'All assets are up to date!'
        return true
      end

      download_assets(missing_assets + outdated_assets)
    end

    def attempt_bulk_download
      # Download the repository as a tar.gz file for faster initial setup
      tar_url = "https://github.com/#{GITHUB_REPO}/archive/refs/heads/#{GITHUB_BRANCH}.tar.gz"
      temp_tar = File.join(VISUALIZER_DIR, 'temp_repo.tar.gz')
      
      respond "Downloading repository archive..."
      
      begin
        # Try with SSL verification
        URI.open(tar_url, ssl_verify_mode: OpenSSL::SSL::VERIFY_PEER, read_timeout: 60) do |remote_file|
          File.binwrite(temp_tar, remote_file.read)
        end
      rescue OpenSSL::SSL::SSLError
        respond "SSL verification failed, retrying without verification..."
        URI.open(tar_url, ssl_verify_mode: OpenSSL::SSL::VERIFY_NONE, read_timeout: 60) do |remote_file|
          File.binwrite(temp_tar, remote_file.read)
        end
      end
      
      respond "Extracting images from archive..."
      extract_images_from_tar(temp_tar)
      
      File.delete(temp_tar) if File.exist?(temp_tar)
      
      respond "Bulk download complete! Verifying checksums..."
      verify_all_checksums
      
      true
    rescue StandardError => e
      respond "Bulk download failed: #{e.message}"
      respond "Falling back to individual file downloads..."
      File.delete(temp_tar) if File.exist?(temp_tar)
      false
    end

    def extract_images_from_tar(tar_path)
      extracted_count = 0
      
      # Open the gzipped tar file
      Zlib::GzipReader.open(tar_path) do |gz|
        Gem::Package::TarReader.new(gz) do |tar|
          tar.each do |entry|
            # GitHub archives have structure: repo-branch/images/filename.png
            next unless entry.full_name.include?('/images/') && entry.full_name.end_with?('.png')
            next unless entry.file?
            
            filename = File.basename(entry.full_name)
            target_path = File.join(VISUALIZER_DIR, filename)
            
            # Extract the file
            File.open(target_path, 'wb') do |f|
              f.write(entry.read)
            end
            
            extracted_count += 1
          end
        end
      end
      
      respond "Extracted #{extracted_count} images from archive"
    end

    def verify_all_checksums
      invalid_count = 0
      
      @manifest.each do |filename, data|
        file_path = File.join(VISUALIZER_DIR, filename)
        next unless File.exist?(file_path)
        
        expected_checksum = data['checksum'] || data['sha256']
        next unless expected_checksum
        
        unless ChecksumValidator.validate?(file_path, expected_checksum)
          respond "  Checksum mismatch for #{filename}, will re-download"
          File.delete(file_path)
          invalid_count += 1
        end
      end
      
      if invalid_count > 0
        respond "Re-downloading #{invalid_count} files with checksum mismatches..."
        missing = find_missing_assets
        download_assets(missing)
      else
        respond "All checksums verified successfully!"
      end
    end

    def bulk_download_repository
      attempt_bulk_download
    end

    def download_manifest
      return false unless manifest_needs_update?

      respond "Downloading manifest from #{MANIFEST_URL}..."
      
      begin
        # Try with OpenSSL verification first
        URI.open(MANIFEST_URL, ssl_verify_mode: OpenSSL::SSL::VERIFY_PEER, read_timeout: 10) do |remote_file|
          content = remote_file.read
          @manifest = YAML.safe_load(content, permitted_classes: [Symbol]) || {}
          File.write(MANIFEST_PATH, content)
          respond "Manifest downloaded successfully (#{@manifest.size} assets listed)"
          return true
        end
      rescue OpenSSL::SSL::SSLError => e
        respond "SSL verification failed, retrying without verification..."
        # Fall back to no SSL verification (for systems with cert issues)
        begin
          URI.open(MANIFEST_URL, ssl_verify_mode: OpenSSL::SSL::VERIFY_NONE, read_timeout: 10) do |remote_file|
            content = remote_file.read
            @manifest = YAML.safe_load(content, permitted_classes: [Symbol]) || {}
            File.write(MANIFEST_PATH, content)
            respond "Manifest downloaded successfully (#{@manifest.size} assets listed)"
            return true
          end
        rescue StandardError => e2
          respond "Error downloading manifest (no SSL): #{e2.message}"
          load_local_manifest
          return false
        end
      rescue StandardError => e
        respond "Error downloading manifest: #{e.message}"
        respond "Error class: #{e.class}"
        load_local_manifest
        return false
      end
    end

    def load_local_manifest
      return false unless File.exist?(MANIFEST_PATH)

      @manifest = YAML.safe_load(File.read(MANIFEST_PATH), permitted_classes: [Symbol]) || {}
      respond "Loaded local manifest (#{@manifest.size} assets)"
      true
    rescue StandardError => e
      respond "Error loading local manifest: #{e.message}"
      @manifest = {}
      false
    end

    private

    def ensure_directory_exists
      FileUtils.mkdir_p(VISUALIZER_DIR) unless File.exist?(VISUALIZER_DIR)
    end

    def manifest_needs_update?
      return true unless File.exist?(MANIFEST_PATH)

      # Check if manifest is older than cache duration
      age_hours = (Time.now - File.mtime(MANIFEST_PATH)) / 3600
      age_hours >= MANIFEST_CACHE_HOURS
    end

    def find_missing_assets
      missing = []
      @manifest.each do |filename, data|
        file_path = File.join(VISUALIZER_DIR, filename)
        missing << { filename: filename, data: data } unless File.exist?(file_path)
      end
      respond "Found #{missing.size} missing assets" unless missing.empty?
      missing
    end

    def find_outdated_assets
      outdated = []
      @manifest.each do |filename, data|
        file_path = File.join(VISUALIZER_DIR, filename)
        next unless File.exist?(file_path)

        expected_checksum = data['checksum'] || data['sha256']
        unless ChecksumValidator.validate?(file_path, expected_checksum)
          outdated << { filename: filename, data: data }
        end
      end
      respond "Found #{outdated.size} outdated assets" unless outdated.empty?
      outdated
    end

    def download_assets(assets)
      return true if assets.empty?

      total = assets.size
      respond "Downloading #{total} asset(s)..."
      respond "This may take a while for large downloads. Progress updates every 10 files."
      
      success_count = 0
      failed_assets = []
      
      assets.each_with_index do |asset, index|
        if download_asset(asset[:filename], asset[:data])
          success_count += 1
          # Show progress every 10 files or at completion
          if (index + 1) % 10 == 0 || (index + 1) == total
            percentage = ((index + 1).to_f / total * 100).round(1)
            respond "  Progress: #{index + 1}/#{total} (#{percentage}%) - #{success_count} successful"
          end
        else
          failed_assets << asset[:filename]
        end
      end

      respond "Download complete: #{success_count}/#{total} assets successfully downloaded"
      
      unless failed_assets.empty?
        respond "Failed downloads (#{failed_assets.size}):"
        failed_assets.first(10).each { |name| respond "  - #{name}" }
        respond "  ... and #{failed_assets.size - 10} more" if failed_assets.size > 10
      end
      
      success_count == total
    end

    def download_asset(filename, data, retry_count = 0)
      # URL-encode the filename for the download URL
      encoded_filename = URI.encode_www_form_component(filename)
      url = "#{@base_url}/#{encoded_filename}"
      file_path = File.join(VISUALIZER_DIR, filename)
      
      begin
        # Try with SSL verification
        URI.open(url, ssl_verify_mode: OpenSSL::SSL::VERIFY_PEER, read_timeout: 30) do |remote_file|
          File.binwrite(file_path, remote_file.read)
        end
      rescue OpenSSL::SSL::SSLError
        # Retry without SSL verification
        URI.open(url, ssl_verify_mode: OpenSSL::SSL::VERIFY_NONE, read_timeout: 30) do |remote_file|
          File.binwrite(file_path, remote_file.read)
        end
      end
      
      # Verify checksum after download
      expected_checksum = data['checksum'] || data['sha256']
      if expected_checksum && !ChecksumValidator.validate?(file_path, expected_checksum)
        File.delete(file_path) if File.exist?(file_path)
        
        # Retry once if checksum fails
        if retry_count < 1
          sleep 0.5
          return download_asset(filename, data, retry_count + 1)
        end
        
        respond "    Checksum mismatch for #{filename} after retry"
        return false
      end
      
      return true
    rescue StandardError => e
      # Retry once on network errors
      if retry_count < 1
        sleep 1
        return download_asset(filename, data, retry_count + 1)
      end
      
      respond "    Error downloading #{filename}: #{e.message}"
      false
    end
  end

  # Configuration management for the Visualizer script
  class Config
    DEFAULT_SETTINGS = {
      'window_position' => [500, 500],
      'window_width' => 500,
      'window_height' => 500,
      'auto_update_assets' => true,
      'last_asset_check' => nil
    }.freeze

    attr_accessor :window_position, :window_width, :window_height, 
                  :auto_update_assets, :last_asset_check

    def initialize
      @config_path = File.join(DATA_DIR, XMLData.game, XMLData.name, 'visualizer_config.yaml')
      load_config
    end

    def load_config
      if File.exist?(@config_path)
        begin
          config = YAML.load_file(@config_path, permitted_classes: [Time]) || {}
          @window_position = config['window_position'] || DEFAULT_SETTINGS['window_position']
          @window_width = config['window_width'] || DEFAULT_SETTINGS['window_width']
          @window_height = config['window_height'] || DEFAULT_SETTINGS['window_height']
          @auto_update_assets = config.fetch('auto_update_assets', DEFAULT_SETTINGS['auto_update_assets'])
          
          # Handle Time object or convert from string
          last_check = config['last_asset_check']
          @last_asset_check = case last_check
                              when Time
                                last_check
                              when String
                                Time.parse(last_check) rescue nil
                              else
                                nil
                              end
        rescue StandardError => e
          respond "Error loading config: #{e.message}"
          load_defaults
        end
      else
        load_defaults
      end
    end

    def save_config
      FileUtils.mkdir_p(File.dirname(@config_path))
      
      config_data = {
        'window_position' => @window_position,
        'window_width' => @window_width,
        'window_height' => @window_height,
        'auto_update_assets' => @auto_update_assets,
        'last_asset_check' => @last_asset_check&.iso8601  # Save as ISO string
      }

      File.write(@config_path, YAML.dump(config_data))
      echo "Config saved to #{@config_path}"
    rescue StandardError => e
      respond "Error saving config: #{e.message}"
    end

    def update_last_asset_check
      @last_asset_check = Time.now
    end

    private

    def load_defaults
      @window_position = DEFAULT_SETTINGS['window_position'].dup
      @window_width = DEFAULT_SETTINGS['window_width']
      @window_height = DEFAULT_SETTINGS['window_height']
      @auto_update_assets = DEFAULT_SETTINGS['auto_update_assets']
      @last_asset_check = DEFAULT_SETTINGS['last_asset_check']
    end
  end

  # Manages image paths and loading for the visualizer
  class ImageManager
    VISUALIZER_DIR = File.join(SCRIPT_DIR, 'Visualizer')
    NULL_IMAGE = File.join(VISUALIZER_DIR, 'null.png')

    def self.check_image_library
      if File.exist?(VISUALIZER_DIR)
        respond "Visualizer directory found: #{VISUALIZER_DIR}"
        return true
      end

      respond ''
      respond 'Visualizer directory not found. Creating it now...'
      FileUtils.mkdir_p(VISUALIZER_DIR)
      respond "Created: #{VISUALIZER_DIR}"
      respond ''
      respond 'Assets will be downloaded automatically from GitHub.'
      respond ''
      true
    end

    def self.image_path_for_room(room)
      # Try room UID first
      uid_path = File.join(VISUALIZER_DIR, "u#{room.uid.max}.png")
      return uid_path if File.exist?(uid_path)

      # Try location name
      location_path = File.join(VISUALIZER_DIR, "#{room.location}.png")
      return location_path if File.exist?(location_path)

      # Fall back to null image
      NULL_IMAGE
    end

    def self.image_exists?(path)
      File.exist?(path) && File.file?(path)
    end

    def self.count_images
      return 0 unless File.exist?(VISUALIZER_DIR)
      Dir.glob(File.join(VISUALIZER_DIR, '*.png')).count
    end
  end

  # Handles the GTK window and image display
  class WindowManager
    attr_reader :window, :exit_requested

    def initialize(config)
      @config = config
      @exit_requested = false
      @window = nil
      @image = nil
      @layout = nil
      @scroller = nil
      @current_image_path = nil
      @current_width = nil
      @current_height = nil
      @current_room_uid = nil
    end

    def create_window
      Gtk.queue { setup_window }
    end

    def load_image_for_room(room)
      @current_image_path = ImageManager.image_path_for_room(room)
      @current_room_uid = room.uid.max
      update_image_display
    end

    def update_on_resize
      return unless window_size_changed?

      @config.window_width = @window.allocation.width
      @config.window_height = @window.allocation.height
      
      update_image_display if @current_width && @current_height
    end

    def cleanup
      capture_window_state
      sleep 0.01 while @config.window_height.nil?
      
      Gtk.queue { @window.destroy }
      @config.save_config
    end

    private

    def setup_window
      @window = Gtk::Window.new
      @window.title = window_title_for_room(Room.current)
      @window.set_icon(@default_icon)
      @window.signal_connect('delete_event') { @exit_requested = true }
      @window.keep_above = true
      
      setup_scroller
      position_and_size_window
      
      load_initial_image
      @window.show_all
    end

    def setup_scroller
      @scroller = Gtk::ScrolledWindow.new
      @scroller.border_width = 0
      @scroller.set_policy(:automatic, :always)
      @window.add(@scroller)

      @layout = Gtk::Layout.new
      @scroller.add(@layout)
    end

    def position_and_size_window
      # Ensure minimum window dimensions
      @config.window_height = [@config.window_height, 100].max
      @config.window_width = [@config.window_width, 100].max
      
      @window.resize(@config.window_width, @config.window_height)

      # Constrain position to screen bounds
      x_pos = [[0, @config.window_position[0].to_i].max,
               (Gdk::Screen.default.width - @config.window_width)].min
      y_pos = [[0, @config.window_position[1].to_i].max,
               Gdk::Screen.default.height].min
      
      @window.move(x_pos, y_pos)
    end

    def load_initial_image
      @current_image_path = ImageManager.image_path_for_room(Room.current)
      @current_room_uid = Room.current.uid.max
      
      return unless ImageManager.image_exists?(@current_image_path)

      load_and_scale_image
    end

    def update_image_display
      return unless @window

      unless ImageManager.image_exists?(@current_image_path)
        remove_current_image
        @window.show_all
        return
      end

      Gtk.queue do
        @window.title = window_title_for_room(Room.current)
        load_and_scale_image
        @window.show_all
      end
    rescue StandardError => e
      respond "Error updating image: #{e.message}"
      remove_current_image
    end

    def load_and_scale_image
      _format, width, height = GdkPixbuf::Pixbuf.get_file_info(@current_image_path)
      @current_width = width
      @current_height = height

      scale = calculate_scale(width)
      scaled_width = (width * scale).to_i
      scaled_height = (height * scale).to_i

      @layout.set_size(scaled_width, scaled_height)
      
      remove_current_image
      
      @image = Gtk::Image.new
      pixbuf = GdkPixbuf::Pixbuf.new(file: @current_image_path)
      @image.set_pixbuf(pixbuf.scale(scaled_width, scaled_height))
      @layout.put(@image, 0, 0)
    end

    def calculate_scale(image_width)
      scale = @config.window_width.to_f / [image_width, 1].max
      [scale, 1].min
    end

    def remove_current_image
      @layout.remove(@image) if @image
      @image = nil
    end

    def window_size_changed?
      @window &&
        @window.allocation.height &&
        @window.allocation.width &&
        (@window.allocation.height != @config.window_height ||
         @window.allocation.width != @config.window_width)
    end

    def window_title_for_room(room)
      "Visualizer - #{room.title} - u#{room.uid[0]}"
    end

    def capture_window_state
      Gtk.queue do
        position = @window.position
        @config.window_position = position if valid_position?(position)
        @config.window_width = @window.allocation.width if valid_dimension?(@window.allocation.width)
        @config.window_height = @window.allocation.height if valid_dimension?(@window.allocation.height)
      end
    end

    def valid_position?(position)
      position.is_a?(Array) && position[0].to_i > 0 && position[1].to_i > 0
    end

    def valid_dimension?(dimension)
      dimension.is_a?(Integer) && dimension > 100
    end
  end

  # Main application controller
  class Application
    POLL_INTERVAL = 0.5
    ASSET_CHECK_INTERVAL_HOURS = 24

    def self.run
      # Parse command line arguments
      if Script.current.vars[1] == 'update'
        force_update_assets
        return
      elsif Script.current.vars[1] == 'help'
        show_help
        return
      end

      new.start
    end

    def self.force_update_assets
      ImageManager.check_image_library
      asset_manager = AssetManager.new
      asset_manager.check_and_update_assets
      respond "Asset update complete!"
    end

    def self.show_help
      respond ''
      respond 'Visualizer - Room image display for Gemstone IV'
      respond ''
      respond 'Usage:'
      respond '  ;visualizer              - Start the visualizer'
      respond '  ;visualizer update       - Force asset update from GitHub'
      respond '  ;visualizer help         - Show this help message'
      respond ''
      respond 'Configuration:'
      respond "  Config file: #{File.join(DATA_DIR, XMLData.game, XMLData.name, 'visualizer_config.yaml')}"
      respond "  Asset directory: #{ImageManager::VISUALIZER_DIR}"
      respond ''
      respond 'GitHub Repository:'
      respond "  #{GITHUB_REPO}"
      respond ''
    end

    def initialize
      @config = Config.new
      @window_manager = WindowManager.new(@config)
      @last_room_uid = Room.current.uid.max
      @asset_manager = AssetManager.new
    end

    def start
      return unless ImageManager.check_image_library

      # Check and update assets if enabled
      check_assets if @config.auto_update_assets

      @window_manager.create_window
      @window_manager.load_image_for_room(Room.current)

      setup_cleanup_hook
      main_loop
    end

    private

    def check_assets
      return unless should_check_assets?

      respond 'Performing automatic asset check...'
      @asset_manager.check_and_update_assets
      @config.update_last_asset_check
      @config.save_config
    end

    def should_check_assets?
      return true if @config.last_asset_check.nil?

      hours_since_check = (Time.now - @config.last_asset_check) / 3600
      hours_since_check >= ASSET_CHECK_INTERVAL_HOURS
    end

    def main_loop
      until @window_manager.exit_requested
        @window_manager.update_on_resize
        check_room_change
        sleep POLL_INTERVAL
      end
    end

    def check_room_change
      current_room_uid = Room.current.uid.max
      return if current_room_uid == @last_room_uid

      # Don't update image by UID if go2 is running (traveling)
      @last_room_uid = current_room_uid unless running?('go2')
      @window_manager.load_image_for_room(Room.current)
    end

    def setup_cleanup_hook
      before_dying { @window_manager.cleanup }
    end
  end
end

# Start the application
Visualizer::Application.run
